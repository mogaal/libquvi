#
# Copyright (C) 2010 Toni Gundogdu.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

package quviTest;

use warnings;
use strict;

use POSIX ":sys_wait_h";
use File::Basename qw(basename);

require Exporter;
use vars qw(@ISA @EXPORT @EXPORT_OK);

our @ISA       = qw(Exporter);
our @EXPORT    = ();
our @EXPORT_OK = qw(run run_t pod_checks check_codeset);

my $QUVI_PATH      = "@top_builddir@/src/quvi";
$ENV{QUVI_BASEDIR} = "@top_srcdir@/share";

# Exit test if NO_INTERNET is set.
sub no_internet {
    if ($ENV{NO_INTERNET}) {
        print STDERR "SKIP: No internet. Unset NO_INTERNET to enable.\n";
        exit (0);
    }
}

# Remove these from the args: we use them for
# default "flv" runs only.
sub remove_checks {
    my (@args) = @_;

    my @remove =
        qw(--page-title --video-id --file-length --file-suffix);

    my @tmp;
    my $skip = 0;

    foreach my $arg (@args) {
        foreach (@remove) {
            if ($arg =~ /$_/) {
                $skip = 1;
                last;
            }
        }
        push @tmp, $arg  if !$skip;
        $skip ||= $skip;
    }

    return @tmp;
}

# Wraps "-t -f $fmt", parses quvi --support output, and
# tests all host supported formats.
sub run_t {
    no_internet();

    my @args    = ("-t", @_);
    my @formats = parse_formats($_[0]);

    my $rc;
    foreach (@formats) {
        $rc = run( ("-f", $_, @args) );
        last if $rc != 0;
        @args = remove_checks(@args);
    }

    return $rc;
}

# Runs quvi with the given options. Checks and
# parses the supported environment variables.
sub run {
    my @args  = ( $QUVI_PATH, @_ );
    my $extra = $ENV{QUVI_TEST_OPTIONS};

    @args = ( @args, split( /\s+/, $extra ) )
        if ($extra);

    foreach (@_) {
        if ( $_ =~ /-t/ ) {
            no_internet();
            last;
        }
    }

    printf "\nTEST: %s\nRUN: ", basename($0);
    print qq/"$_"/ . " " foreach @args;
    print "\n";

    my $child = fork;
    if ( $child < 0 ) {
        die "fork: $! ($?)";
    }
    elsif ( $child == 0 ) {
        exit( system(@args) >> 8 );
    }

    print "\n";

    my $rc;
    while (1) {
        my $result = waitpid( $child, 0 );

        if ( $result == -1 ) {
            die "no more processes to wait: pid $child not found";
        }
        elsif ( $result == 0 ) {

            # $child is still running.
            next;
        }
        elsif ( $result != $child ) {
            die "got invalid pid $result (expected $child)";
        }

        print STDERR "  ";

        my $status = $?;
        if ( WIFEXITED($status) ) {
            $rc = WEXITSTATUS($status);
            print STDERR "-> child: normal termination ($rc)\n";
            last;
        }
        elsif ( WIFSIGNALED($status) ) {
            $rc = WTERMSIG($status);
            print STDERR "-> child: abnormal termination ($rc)\n";
            last;
        }
        elsif ( WIFSTOPPED($status) ) {
            $rc = WSTOPSIG($status);
            print STDERR "-> child: stopped ($rc)\n";
            last;
        }
    }

    return $rc;
}

# Parses quvi --support output. First argument is
# expected to be the host id, e.g. "youtube".
sub parse_formats {
    my $output = `$QUVI_PATH --support`;
    my $host = shift;
    my @r = ();
    if ($output =~ /$host\.(?:\w+\s+|\s+)(.*)/i) {
        @r = split(/\|/,$1);
    }
    return @r;
}

# Check the pod markup.
sub pod_checks {
    require Pod::Checker;
    my $rc = Pod::Checker::podchecker("@top_srcdir@/man1/quvi.1.pod");
    return $rc;
}

# Returns current locale codeset. Terminates if codeset
# is not matched to UTF-8/16/32.
sub check_codeset {
    my $cs;
    eval {
        require I18N::Langinfo;
        I18N::Langinfo->import( qw(langinfo CODESET) );
        $cs = langinfo( CODESET() );
    };
    my $skip = 0;
    if ($@) { $skip = 1; }
    else    { if ($cs !~ /^utf/i) { $skip = 1; } }
    if ($skip) {
        print STDERR "SKIP: No utf-8 (or utf-16, utf-32) locale codeset.\n";
        exit (0);
    }
}

1;
